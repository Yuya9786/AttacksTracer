package malwaresimulator.engine.nodes

import akka.actor.typed.Behavior
import akka.actor.typed.scaladsl.Behaviors
import malwaresimulator.engine.core.{Connection, Datagram, InetAddress, Message}
import malwaresimulator.engine.{ActorType, TraceLogger, nodes}

import scala.collection.mutable.ListBuffer

abstract trait Firewall extends NetworkNode {
  var firewallRules: ListBuffer[FirewallRule] = ListBuffer.empty
  val name: String
  /**
   * 新しいファイアウォールルールを追加する
   * @param newRule 新しいファイアウォールルール
   */
  def addRule(newRule: FirewallRule): Unit = {
    firewallRules += newRule
    TraceLogger.info(ActorType.Node, name, s"added firewall rule: ${newRule}")
  }

  /**
   * ファイアウォールルールでdenyに指定されているかをチェックする
   * @param d ルールと照らし合わせるデータグラム
   * @return true  denyに指定されている
   * @return false denyに指定されていない
   */
  def checkDenyDatagram(d: Datagram): Boolean = {
    val matchDatagram = nodes.FirewallRule("deny",
      d.srcAddress,
      d.srcPort,
      d.dstAddress,
      d.dstPort)
    firewallRules.find(check => check == matchDatagram) match {
      case Some(check) => {
        TraceLogger.info(ActorType.Node, name, s"deny by ${check}", d);
        true
      }
      case None => false
    }
  }

  /**
   *  自分宛のデータグラムならば受け取り，アプリケーションがあればそこに送る
   *  自分宛では無くルーティング可能なら該当ネットワークにデータグラムを転送
   *  ただしファイアウォールルールによって転送するか破棄するかを決める
   *  @param d 受け取るデータグラム
   */
  override def networkResponse(d: Datagram): Unit = {
    val dstAddress: InetAddress = d.dstAddress // 行き先アドレス

    if (!checkDenyDatagram(d)) {
      if (connections.exists(_.address == dstAddress)) {
        // 設定されている接続のうち一つでも行き先アドレスのものが会ったら
        receiveDatagram(d)  // データグラムを受け取る　
      } else {
        // 行き先が同じネットワークに接続されているものがあればルーティング
        // する必要がないので，ロンゲストマッチで直接送信する
        val list = connections.filter(con => {con.address.isSameNetwork(d.dstAddress, con.netmask)})
        list.length match {
          case 0 => deliverDatagram(d)
          case 1 =>
            TraceLogger.info(ActorType.Node, this.name, s"forward to ${list.head.address}/${list.head.netmask}", d)
            list.head.network ! Datagram(d.srcAddress, d.srcPort, d.dstAddress, d.dstPort, d.value)
          case _ =>
            var longest: Connection = null
            var count: Int = -1
            for (con <- list) {
              if (count < con.netmask) {
                count = con.netmask
                longest = con
              }
            }
            if (longest == null) {
              // TODO:どういう例外あげればいいかわからない
              TraceLogger.error(ActorType.Node, this.name, "connection is not found", d)
              return
            }
            TraceLogger.info(ActorType.Node, this.name, s"forward to ${longest.address}/${longest.netmask}", d)
            longest.network ! Datagram(d.srcAddress, d.srcPort, d.dstAddress, d.dstPort, d.value)
        }
      }
    } else { TraceLogger.info(ActorType.Node, name, "denied", d) }
  }

}
