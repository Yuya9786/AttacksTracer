package malwaresimulator.engine.nodes

import akka.actor.typed.ActorRef
import malwaresimulator.engine.TraceLogger
import malwaresimulator.engine.core.{Connection, Data, Datagram, InetAddress, Message, Network}

import scala.collection.mutable.ListBuffer

///**
// * ネットワーク接続を持つノード
// */

trait NetworkNode {
  final case class SetAddress(address: InetAddress) extends Message.NodeCommand
  final case class GetAddress(replyTo: ActorRef[Message.Command]) extends Message.NodeCommand
  final case class ReturnAddress(address: InetAddress) extends Message.NodeCommand

  val sockets = new Sockets
  var connections: ListBuffer[Connection] = ListBuffer.empty
  val name: String
  private var fileList: ListBuffer[String] = ListBuffer() // 重要データ（元の型はFileクラス）
  var responses: ListBuffer[(Datagram) => Unit] = ListBuffer.empty
  private val rtable: RoutingTable = RoutingTable() /* 経路表 */

  responses += networkResponse

  /**
   * アドレスを取得する
   * @return アドレス
   */
//  def getAddress(): InetAddress = { this.address }

  /**
   *  自分宛のデータグラムならば受け取り，アプリケーションがあればそこに送る
   *  自分宛では無くルーティング可能なら該当ネットワークにデータグラムを転送
   *  @param d 受け取るデータグラム
   */
  protected def networkResponse(d: Datagram): Unit = {
    val dstAddress: InetAddress = d.dstAddress

    if (connections.exists(_.address == dstAddress)) {
      // 設定されている接続のうち一つでも行き先アドレスのものが会ったら
      receiveDatagram(d)  // データグラムを受け取る　
    } else {
      TraceLogger.info(this.name, "Deliver internal", d)
      // 行き先が同じネットワークに接続されているものがあればルーティング
      // する必要がないので，直接送信する
      connections.find(con => {con.address.isSameNetwork(d.dstAddress, con.netmask)})
      match {
        case Some(con) => con.network ! d
        case None => deliverDatagram(d)
      }
    }
  }

  /**
   *  自分宛のデータグラムを受け取って処理
   *  @param d 自分宛のデータグラム
   *  TODO: Override this method
   */
  protected def receiveDatagram(d: Datagram): Unit = {
    TraceLogger.info(this.name, "Received", d)
  }

  /**
   *  ネットワークに結びついたアドレスを返す
   *  @param network 指定するネットワーク
   *  @return 　　　　ネットワークに結びついたアドレス
   */
  def getAddressBindedNetwork(network: ActorRef[Message.NetworkCommand]): InetAddress = {
    val con = connections.find(_.network == network)
    con match {
      case Some(s) => s.address
      case None    => InetAddress.Default
    }
  }

  /**
   *  接続を作成
   *  @param connection
   */
  def makeConnection(connection: Connection): Unit = {
    connections += connection
  }

  /**
   *  アドレスとネットワークを指定して接続を作成
   *  @param address 自ノードに設定するアドレス
   *  @param net  繋がる先のネットワーク
   */
  def makeConnection(address: InetAddress, netmask: Int, net: ActorRef[Message.NetworkCommand]): Unit = {
    connections += Connection(address, netmask, net)
  }

  /**
   *  Connection をすべて表示
   */
  def displayAllConnections(): Unit = {
    connections.foreach { conn =>
      println(this + " connects to " + conn)
    }
  }

  /**
   *  経路表を得る
   *  @return 経路表
   */
  def getRoutingTable: RoutingTable = rtable

  /**
   * 　ルーティング表を経路を追加する
   */
  def addRoute(dest: InetAddress, netmask: Int, nexthop: InetAddress, conn: Connection): this.type = {
    rtable.addRoute(dest, netmask, nexthop, conn)
    this
  }

  def addRoute(dest: InetAddress, netmask: Int, nexthop: InetAddress, net: ActorRef[Message.NetworkCommand]): this.type = {
    val conn = connections.filter(_.network == net)
    if (!conn.isEmpty) addRoute(dest, netmask, nexthop, conn.head)
    else {
      println("Fatal error. Cannot add a route.")
    }
    this
  }

  /**
   *   自分宛では無いデータグラムについての処理
   *   @param d 自分宛では無いデータグラム
   */
  def deliverDatagram(d: Datagram): Either[Unit, String] = {

    // 行先アドレスにデータグラムを投げるための情報を得る
    val route = rtable.routing(d) match {
      case Left(route) => route
      case Right(msg) => return Right("No route to host" + msg)
    }
    // ネクストホップのアドレスを追加してネットワークにデータグラムを送る
    Left(route.connection.network ! Datagram(d.srcAddress, d.srcPort, d.dstAddress, d.dstPort, d.value, route.nexthop, d.option))
  }


  class Sockets {
    var sockets: ListBuffer[Socket] = ListBuffer.empty

    def open(actor: ActorRef[Message.ApplicationCommand]): Socket = {
      val s = new Socket(actor)
      sockets += s
      s
    }

    def bind(s: Socket, address: InetAddress, port: Int): Either[Unit, String] = {
      select(address, port) match {
        case Some(s) => Right("address already in use.")
        case None => Left {
          s.localAddress = address
          s.localPort = port
        }
      }
    }

    def select(localAddress: InetAddress, localPort: Int): Option[Socket] = {
      for (s <- sockets) {
        if ((s.localAddress == InetAddress.Default || s.localAddress == localAddress) && s.localPort == localPort) {
          return Some(s)
        }
      }
      None
    }


    def sendto(s: Socket, data: Data, dstAddress: InetAddress, dstPort: Int): Either[Unit, String] = {
      var connection: Connection = null
      if (s.localAddress == InetAddress.Default) {
        val route = rtable.routing(dstAddress) match {
          case Left(route) => route
          case Right(msg) => return Right(msg)
        }
        connection = route.connection
        s.localAddress = route.connection.address
      } else {
        connection = connections.find(con => con.address == s.localAddress) match {
          case Some(c) => c
          case None =>
            return Right(s"Connction not found, addr=${s.localAddress.toString}")
        }
      }
      if (s.localPort == 0) {
        (49152 to 65535).find(p => select(s.localAddress, p) == None) match {
          case Some(p) => s.localPort = p
          case None => {
            return Right("Failed to dynamic assign local port.")
          }
        }
      }
      Left(connection.network ! data.datagram(s.localAddress, s.localPort, dstAddress, dstPort))
    }

    def recv(s: Socket): Either[Datagram, String] = {
      s.buffer.isEmpty match {
        case true => Right(s"The buffer of ${s} is empty.")
        case false =>
          val datagram = s.buffer.head
          s.buffer -= s.buffer.head
          Left(datagram)
      }
    }
  }
}

class Socket(val actor: ActorRef[Message.ApplicationCommand]) {
  var localAddress: InetAddress = InetAddress.Default
  var localPort: Int = 0
  var buffer: ListBuffer[Datagram] = ListBuffer.empty
}
