package malwaresimulator.engine.nodes

import akka.actor.typed.ActorRef
import malwaresimulator.engine.{ActorType, TraceLogger}
import malwaresimulator.engine.core.{Connection, Data, Datagram, InetAddress, Message}

import scala.collection.mutable.{ListBuffer, Map}

///**
// * ネットワーク接続を持つノード
// */

trait NetworkNode {
  final case class SetAddress(address: InetAddress) extends Message.NodeCommand
  final case class GetAddress(replyTo: ActorRef[Message.Command]) extends Message.NodeCommand
  final case class ReturnAddress(address: InetAddress) extends Message.NodeCommand

  val sockets = new Sockets
  var connections: ListBuffer[Connection] = ListBuffer.empty
  val name: String
  private var fileList: ListBuffer[String] = ListBuffer() // 重要データ（元の型はFileクラス）
  var responses: ListBuffer[(Datagram) => Unit] = ListBuffer.empty
  private val rtable: RoutingTable = RoutingTable() /* 経路表 */

  responses += networkResponse

  /**
   * アドレスを取得する
   * @return アドレス
   */
//  def getAddress(): InetAddress = { this.address }

  /**
   *  自分宛のデータグラムならば受け取り，アプリケーションがあればそこに送る
   *  自分宛では無くルーティング可能なら該当ネットワークにデータグラムを転送
   *  @param d 受け取るデータグラム
   */
  protected def networkResponse(d: Datagram): Unit = {
    val dstAddress: InetAddress = d.dstAddress

    if (connections.exists(_.address == dstAddress)) {
      // 設定されている接続のうち一つでも行き先アドレスのものが会ったら
      receiveDatagram(d)  // データグラムを受け取る　
    } else {
      TraceLogger.info(ActorType.Node, this.name, "deliver internal", d)
      // 行き先が同じネットワークに接続されているものがあればルーティング
      // する必要がないので，ロンゲストマッチで直接送信する
      val list = connections.filter(con => {con.address.isSameNetwork(d.dstAddress, con.netmask)})
      list.length match {
        case 0 => deliverDatagram(d)
        case 1 =>
          TraceLogger.info(ActorType.Node, this.name, s"forward to ${list.head.address}/${list.head.netmask}", d)
          list.head.network ! Datagram(d.srcAddress, d.srcPort, d.dstAddress, d.dstPort, d.value)
        case _ =>
          var longest: Connection = null
          var count: Int = 0
          for (con <- list) {
            if (count < con.netmask) {
              count = con.netmask
              longest = con
            }
          }
          if (longest == null) {
            // TODO:どういう例外あげればいいかわからない
            return
          }
          TraceLogger.info(ActorType.Node, this.name, s"forward to ${longest.address}/${longest.netmask}", d)
          longest.network ! Datagram(d.srcAddress, d.srcPort, d.dstAddress, d.dstPort, d.value)
      }
    }
  }

  /**
   *  自分宛のデータグラムを受け取って処理
   *  @param d 自分宛のデータグラム
   *  TODO: Override this method
   */
  protected def receiveDatagram(d: Datagram): Unit = {
    TraceLogger.info(ActorType.Node, this.name, "Received", d)
  }

  /**
   *  ネットワークに結びついたアドレスを返す
   *  @param network 指定するネットワーク
   *  @return 　　　　ネットワークに結びついたアドレス
   */
  def getAddressBindedNetwork(network: ActorRef[Message.NetworkCommand]): InetAddress = {
    val con = connections.find(_.network == network)
    con match {
      case Some(s) => s.address
      case None    => InetAddress.Default
    }
  }

  /**
   *  接続を作成
   *  @param connection
   */
  def makeConnection(connection: Connection): Unit = {
    connections += connection
  }

  /**
   *  アドレスとネットワークを指定して接続を作成
   *  @param address 自ノードに設定するアドレス
   *  @param net  繋がる先のネットワーク
   */
  def makeConnection(address: InetAddress, netmask: Int, net: ActorRef[Message.NetworkCommand]): Unit = {
    connections += Connection(address, netmask, net)
  }

  /**
   *  Connection をすべて表示
   */
  def displayAllConnections(): Unit = {
    connections.foreach { conn =>
      println(this + " connects to " + conn)
    }
  }

  /**
   *  経路表を得る
   *  @return 経路表
   */
  def getRoutingTable: RoutingTable = rtable

  /**
   * 　ルーティング表を経路を追加する
   */
  def addRoute(dest: InetAddress, netmask: Int, nexthop: InetAddress, conn: Connection): this.type = {
    rtable.addRoute(dest, netmask, nexthop, conn)
    this
  }

  def addRoute(dest: InetAddress, netmask: Int, nexthop: InetAddress, net: ActorRef[Message.NetworkCommand]): this.type = {
    val conn = connections.filter(_.network == net)
    if (!conn.isEmpty) addRoute(dest, netmask, nexthop, conn.head)
    else {
      TraceLogger.error(ActorType.Node, this.name, "Cannot add a route.")
    }
    this
  }

  /**
   *   自分宛では無いデータグラムについての処理
   *   @param d 自分宛では無いデータグラム
   */
  def deliverDatagram(d: Datagram): Either[Unit, String] = {

    // 行先アドレスにデータグラムを投げるための情報を得る
    val route = rtable.routing(d) match {
      case Left(route) => route
      case Right(msg) => return Right("No route to host" + msg)
    }
    // ネクストホップのアドレスを追加してネットワークにデータグラムを送る
    val datagram = Datagram(d.srcAddress, d.srcPort, d.dstAddress, d.dstPort, d.value, route.nexthop, d.option)
    TraceLogger.info(ActorType.Node, this.name, s"forward to ${route.connection.address}/${route.connection.netmask}", datagram)
    Left(route.connection.network ! datagram)
  }


  class Sockets {
    var sockets: Map[String, Socket] = Map.empty

    def open(actor: ActorRef[Message.ApplicationCommand], key: String): Unit = {
      val s = new Socket(actor)
      sockets += (key -> s)
    }

    def bind(socket: String, address: InetAddress, port: Int): Either[Unit, String] = {
      select(address, port) match {
        case Some(s) => Right("address already in use.")
        case None => Left {
          val s = sockets(socket)
          s.localAddress = address
          s.localPort = port
        }
      }
    }

    def select(localAddress: InetAddress, localPort: Int): Option[Socket] = {
      for (s <- sockets) {
        val socket = s._2
        if ((socket.localAddress == InetAddress.Default || socket.localAddress == localAddress) && socket.localPort == localPort) {
          return Some(socket)
        }
      }
      None
    }

    def connect(socket: String, dstAddress: InetAddress, dstPort: Int): Unit = {
      val s: Socket = sockets(socket)
      s.dstAddress = dstAddress
      s.dstPort = dstPort
    }

    def sendto(key: String, data: Data, dstAddress: InetAddress, dstPort: Int): Either[Unit, String] = {
      var connection: Connection = null
      var nexthop: InetAddress = null
      val s: Socket = sockets(key)
      if (s.localAddress == InetAddress.Default) {
        val route = rtable.routing(dstAddress) match {
          case Left(route) => route
          case Right(msg) => return Right(msg)
        }
        connection = route.connection
        nexthop = route.nexthop
        s.localAddress = route.connection.address
      } else {
        connection = connections.find(con => con.address == s.localAddress) match {
          case Some(c) => c
          case None =>
            return Right(s"Connection not found, addr=${s.localAddress.toString}")
        }
        val route = rtable.routing(dstAddress) match {
          case Left(route) => route
          case Right(msg) => return Right(msg)
        }
        nexthop = route.nexthop
      }
      if (s.localPort == 0) {
        (49152 to 65535).find(p => select(s.localAddress, p) == None) match {
          case Some(p) => s.localPort = p
          case None => {
            return Right("Failed to dynamic assign local port.")
          }
        }
      }
      Left(connection.network ! data.datagram(s.localAddress, s.localPort, dstAddress, dstPort, nexthop))
    }

    def recv(key: String): Either[Datagram, String] = {
      val s: Socket = sockets(key)
      s.buffer.isEmpty match {
        case true => Right(s"The buffer of ${s} is empty.")
        case false =>
          val datagram = s.buffer.head
          s.buffer -= s.buffer.head
          Left(datagram)
      }
    }
  }
}

class Socket(val actor: ActorRef[Message.ApplicationCommand]) {
  var localAddress: InetAddress = InetAddress.Default
  var localPort: Int = 0
  var dstAddress: InetAddress = InetAddress.Default
  var dstPort: Int = 0
  var buffer: ListBuffer[Datagram] = ListBuffer.empty
}
