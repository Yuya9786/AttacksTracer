package malwaresimulator.engine.nodes

import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.Behavior
import akka.pattern.StatusReply
import akka.util.Timeout
import malwaresimulator.engine.{ActorType, TraceLogger}
import malwaresimulator.engine.core.{Datagram, Message}
import malwaresimulator.proto

import scala.concurrent.duration.DurationInt
import scala.util.{Failure, Success}

object Node {

  def apply(id: Int, name: String) = {
    TraceLogger.info(ActorType.Node, name, "started")
    new Node(id, name).receive()
  }
}

class Node(val id: Int, val name: String) extends ExecutableNode with Firewall {

  def receive(): Behavior[Message.NodeCommand] = {
    implicit val timeout: Timeout = 3.seconds
    import Message._
    Behaviors.receive{ (context, message) =>
      message match {
        case d: Datagram =>
          TraceLogger.info(ActorType.Node, this.name, "received", d)
          networkResponse(d)
          Behaviors.same

        case MakeConnection(replyTo, address, netmask, net) =>
          context.askWithStatus(net, ref => AddNode(ref, context.self, address)) {
            case Success(_) => MakeConnectionSuccess(replyTo, address, netmask, net)
            case Failure(exception) => MakeConnectionFailure(replyTo, exception)
          }
          Behaviors.same
        case MakeConnectionSuccess(replyTo, address, netmask, netRef) =>
          TraceLogger.info(ActorType.Node, name, s"added a connection $address/$netmask")
          makeConnection(address, netmask, netRef)
          replyTo ! StatusReply.Success()
          Behaviors.same
        case MakeConnectionFailure(replyTo, exception) =>
          replyTo ! StatusReply.error(exception)
          Behaviors.same

        case SetApplication(replyTo, id, appName) =>
          TraceLogger.info(ActorType.Node, name, s"received SetApplication($id, $appName)")
          setApplication(id, name)
          replyTo ! StatusReply.success()
          Behaviors.same

        case ShowConnections(replyTo) =>
          replyTo ! ConnectionsList(connections)
          Behaviors.same
        case SetWebServer(id, name, actorRef) =>
          setApplication(id, name)
          Behaviors.same
        case SetWebBrowser(id, name, actorRef) =>
          setApplication(id, name)
          Behaviors.same
        case GetApplications(replyTo) =>
          replyTo ! malwaresimulator.proto.Node(
            id,
            name,
            connections.map(c => malwaresimulator.proto.Connection(c.address.toString, c.netmask)).toSeq,
            getApplications())
          Behaviors.same

        case SocketSys(replyTo, app, key) =>
          sockets.open(app, key)
          replyTo ! StatusReply.Success()
          Behaviors.same

        case BindSys(replyTo, s, address, port) =>
          sockets.bind(s, address, port) match {
            case Left(_) => replyTo ! StatusReply.success(s)
            case Right(msg) => replyTo ! StatusReply.error(msg)
          }
          Behaviors.same

        case ConnectSys(replyTo, socket, dstAddress, dstPort) =>
          sockets.connect(socket, dstAddress, dstPort)
          replyTo ! StatusReply.success()
          Behaviors.same

        case SendSys(replyTo, key, data, dstAddress, dstPort) =>
          sockets.sendto(key, data, dstAddress, dstPort) match {
            case Left(_) => replyTo ! StatusReply.success()
            case Right(msg) => replyTo ! StatusReply.error(msg)
          }
          Behaviors.same

        case RecvSys(replyTo, socket) =>
          sockets.recv(socket) match {
            case Left(datagram) => replyTo ! StatusReply.success(datagram)
            case Right(msg) => replyTo ! StatusReply.error(msg)
          }
          Behaviors.same

        case AddRule(rule) =>
          addRule(rule)
          Behaviors.same
        case AddRoute(replyTo, dst, netmask, nexthop, net) =>
          addRoute(dst, netmask, nexthop, net)
          replyTo ! StatusReply.Success()
          Behaviors.same
        case Infect(replyTo, malwareName, malware, ccServer) =>
          infection(malwareName, malware)
          replyTo ! StatusReply.Success()
          Behaviors.same

        case UpdateNodeInfo(replyTo, id) =>
          val cs = connections.toSeq.map(c => proto.Connection(c.address.toString, c.netmask))
          val reply = proto.Node(id, this.name, cs, getApplications())
          replyTo ! StatusReply.success(reply)
          Behaviors.same

        case StopNode() =>
          Behaviors.stopped
      }
    }
  }
}
