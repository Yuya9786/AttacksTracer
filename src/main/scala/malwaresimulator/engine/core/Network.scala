package malwaresimulator.engine.core

import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.{ActorRef, Behavior}
import akka.pattern.StatusReply
import akka.util.Timeout
import malwaresimulator.engine.TraceLogger
import malwaresimulator.proto

import scala.collection.mutable.ListBuffer
import scala.concurrent.duration.DurationInt

case class NodeAddress(node: ActorRef[Message.NodeCommand], address: InetAddress)

object Network {

  def apply(id: Int, networkName: String, netAddress: InetAddress, subnetMask: Int): Behavior[Message.NetworkCommand] = {
    println(s"[INFO] Network($networkName) is started.")
    new Network(id, networkName, netAddress, subnetMask).receive()
  }
}

class Network(val id: Int, val networkName: String, val netAddress: InetAddress, val subnetMask: Int) {

  private var nodes: ListBuffer[NodeAddress] = ListBuffer.empty
  def receive(): Behavior[Message.NetworkCommand] = {
    import Message._
    implicit val timeout: Timeout = Timeout(3.seconds)
    Behaviors.receive { (context, message) =>
      message match {
        case AddNode(replyTo, node, address) =>
          nodes.find(n => n.address == address) match {
            case Some(n) =>
              TraceLogger.error(this.networkName, s"Node($n) has been added already.")
              replyTo ! StatusReply.Error(s"Node($n) has been added already.")
              Behaviors.same
            case None =>
              nodes += NodeAddress(node, address)
              TraceLogger.info(this.networkName, s"$node, $address is added network(${netAddress.toString})")
              replyTo ! StatusReply.Success()
              Behaviors.same
          }
        case RemoveNode(node, address) =>
          nodes -= NodeAddress(node, address)
          Behaviors.same
        case ShowNode(replyTo) =>
          replyTo ! Nodes(nodes)
          Behaviors.same
        case ShowNetwork(replyTo) =>
          println("nodes: " + nodes)
          println(s"[INFO] Network($networkName) received a ShowNetwork message.")
          val uuid = java.util.UUID.randomUUID().toString
          context.spawn(collectNodeInfo(replyTo), s"ShowNetworkActor-$uuid")
          Behaviors.same
        case d: Datagram =>
          println(s"[INFO] ${this} received ${d}.")
          var dstAddress: InetAddress = d.dstAddress
          if (d.nexthop != null) dstAddress = d.nexthop
          nodes.find(n => n.address == dstAddress) match {
            case Some(n) =>
              n.node ! d
              println(s"[INFO] ${this} switched ${d} to ${n}")
              Behaviors.same
            case None =>
              println(s"[ERR] Node Not found. Datagram=${d}")
              Behaviors.same
          }
      }
    }
  }

  def collectNodeInfo(replyTo: ActorRef[StatusReply[proto.Network]]): Behavior[AnyRef] = {
    Behaviors.setup[AnyRef] { context =>
      println("nodes: " + nodes)
      nodes.foreach(_.node ! Message.GetApplications(context.self))
      var count = nodes.length
      var list: Seq[proto.Node] = Seq.empty
      def next(): Behavior[AnyRef] = {
        if (count > 0) {
          Behaviors.same
        } else {
          println("[INFO] Network Actor sends NodeInfo to Supervisor")
          replyTo ! StatusReply.Success(proto.Network(id, networkName, netAddress.toString, subnetMask, list))
          Behaviors.stopped
        }
      }

      Behaviors.receiveMessage {
        case node: proto.Node =>
          println("[INFO] ERFSDFKJBKNBFKND")
          count -= 1
          list = list :+ node
          next()
        case _ =>
          Behaviors.unhandled
      }
    }
  }
}

//class Network(networkName: String, netAddress: InetAddress)
//
//object Network {
//  trait NetworkCommand
//
//  final case class addNode(node: ActorRef[NetworkCommand], addr: InetAddress) extends NetworkCommand
//  final case class addedNode(addr: InetAddress, from: ActorRef[NetworkCommand]) extends NetworkCommand
//  final case class removeNode(node: ActorRef[NetworkCommand], addr: InetAddress) extends NetworkCommand
//  final case class getAddress(replyTo: ActorRef[Command]) extends NetworkCommand
//
//  var name: String = _
//  var nodes: ListBuffer[NodeAddress] = ListBuffer.empty
//
//  def apply(name: String, netaddr: InetAddress) = network(name, netaddr, ListBuffer.empty)
//
//  private def network(name: String, netaddr: InetAddress, nodes: ListBuffer[NodeAddress]): Behavior[NetworkCommand] = {
//    Behaviors.receive { (context, message) =>
//      message match {
//        case d: Datagram =>
//          context.log.info("{} received {}", this, d)
//          var dstAddress: InetAddress = d.dstAddr
//          // データグラムに gw　が設定されていたら，そちらに振り向ける
//          if (d.forward != null) dstAddress = d.forward
//          // ノードのアドレスが行き先アドレスのものを選ぶ
//          nodes.find(node => (node.address == dstAddress)) match {
//            case Some(node) =>
//              node.node ! d
//              Behaviors.same
//            case None =>
//              context.log.error("NetworkNode not found: {}", d)
//              Behaviors.same
//          }
//        case addNode(node, addr) =>
//          nodes.find(_.address == addr) match { // 元は nodes.find(_ == NodeAddress(node1, addr))
//            case Some(node) =>
//              println("[ERR]", this+": node, "+ node + ", has been added already.")
//              Behaviors.same
//            case None => {
//              node ! addedNode(netaddr, context.self)
//              network(name, netaddr, nodes += NodeAddress(node, addr))
//            }
//          }
//        case removeNode(node, addr) =>
//          network(name, netaddr, nodes -= NodeAddress(node, addr))
//      }
//    }
//  }
//}

//object Network(networkName: String, address: InetAddress) extends MessageActor {
//  val name = networkName
//  /**
//   * NetworkNode と InetAddress の対で登録ノードを保持
//   */
//  var nodes: ListBuffer[NodeAddress] = ListBuffer.empty
//
//  /* データぐらむを受け取ったら行うアクションを設定する */
//  addResponse((d: Datagram) => {
//    println(this, "received", d)
//    // 行き先ノードのアドレス
//    var dstAddress: InetAddress = d.dstAddr
//    // データグラムに gw　が設定されていたら，そちらに振り向ける
//    if (d.forward != null) dstAddress = d.forward
//    // ノードのアドレスが行き先アドレスのものを選ぶ
//    nodes.find(node => (node.address == dstAddress)) match {
//      case Some(node) => node.node ! d // データグラムを送信
//      case None => println("[ERR] NetworkNode not found.", this+":"+d)  // エラーメッセージ
//        /*登録されている全てのノードのアドレス行きか調べて
//        * そのアドレスがついていたら，そこにデータグラムを送信する*/
//    }
//  })
//
//  def addNode(node1: NetworkNode, addr: InetAddress): this.type = {
//    nodes.find(_.address == addr) match { // 元は nodes.find(_ == NodeAddress(node1, addr))
//      case Some(node) => println("[ERR]", this+": node, "+ node + ", has been added already.")
//      case None => {
//        node1.
//      }
//    }
//  }
//}
