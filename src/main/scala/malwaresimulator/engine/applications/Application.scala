package malwaresimulator.engine.applications

import scala.util.{Failure, Success}
import akka.actor.typed.{ActorRef, Behavior}
import akka.actor.typed.scaladsl.Behaviors
import akka.pattern.StatusReply
import akka.util.Timeout
import malwaresimulator.engine.TraceLogger
import malwaresimulator.engine.core.{Datagram, Http, InetAddress, Message, Protocol, Raw}
import malwaresimulator.engine.nodes.Socket

import scala.concurrent.duration.DurationInt

object Application {
  def apply(id: Int, name: String, node: ActorRef[Message.NodeCommand]) = {
    TraceLogger.info(name, s"is started.")
    new Application(id, name, node).response()
  }
}

class Application(val id: Int, val name: String, val node: ActorRef[Message.NodeCommand]) {
  var sockets: Array[String] = Array.empty

  def response(): Behavior[Message.ApplicationCommand] = {
    import Message._
    implicit val timeout: Timeout = 3.seconds
    Behaviors.receive { (context, message) =>
      message match {
        case SocketApp(replyTo, key) =>
          context.askWithStatus(node, ref => SocketSys(ref, context.self, key)){
            case Success(_) => SocketSuccess(key, replyTo)
            case Failure(ex) => SocketFailure(ex, replyTo)
          }
          Behaviors.same
        case SocketSuccess(key, replyTo) =>
          sockets :+ key
          replyTo ! StatusReply.Success()
          Behaviors.same
        case SocketFailure(ex, replyTo) =>
          replyTo ! StatusReply.error(ex)
          Behaviors.same

        case SendApp(replyTo, key, dstAddress, dstPort, data) =>
          sockets.exists(s => s == key) match {
            case true =>
              context.askWithStatus(node, ref => SendSys(ref, key, data, dstAddress, dstPort)) {
                case Success(_) => SendSuccess(replyTo)
                case Failure(ex) => SendFailure(replyTo, ex)
              }
            case false =>
              replyTo ! StatusReply.Error(s"Not found socket: $key")
          }
          Behaviors.same
        case SendSuccess(replyTo) =>
          replyTo ! StatusReply.success()
          Behaviors.same
        case SendFailure(replyTo, ex) =>
          replyTo ! StatusReply.error(ex)
          Behaviors.same

        case BindApp(replyTo, socket, address, port) =>
          sockets.exists(s => s == socket) match {
            case true =>
              context.askWithStatus(node, ref => BindSys(ref, socket, address, port)) {
                case Success(_) => BindSuccess(replyTo, socket)
                case Failure(ex) => BindFailure(replyTo, ex)
              }
            case false =>
              replyTo ! StatusReply.Error(s"Not found socket: $socket")
          }
          Behaviors.same
        case BindSuccess(replyTo, socket) =>
          replyTo ! StatusReply.success(socket)
          Behaviors.same
        case BindFailure(replyTo, ex) =>
          replyTo ! StatusReply.error(ex)
          Behaviors.same

        case RecvApp(replyTo, socket) =>
          sockets.exists(s => s == socket) match {
            case true =>
              context.askWithStatus(node, ref => RecvSys(ref, socket)) {
                case Success(data) => RecvSuccess(replyTo, data)
                case Failure(ex) => RecvFailure(replyTo, ex)
              }
          }
          Behaviors.same
        case RecvSuccess(replyTo, data) =>
          replyTo ! StatusReply.success(data)
          Behaviors.same
        case RecvFailure(replyTo, ex) =>
          replyTo ! StatusReply.error(ex)
          Behaviors.same

        case KillApp() =>
          TraceLogger.info(name, "Receive KillApp() and then stopping...")
          Behaviors.stopped
      }
    }
  }
}
