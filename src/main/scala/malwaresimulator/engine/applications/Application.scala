package malwaresimulator.engine.applications

import scala.util.{Failure, Success}
import akka.actor.typed.{ActorRef, Behavior}
import akka.actor.typed.scaladsl.Behaviors
import akka.pattern.StatusReply
import akka.util.Timeout
import malwaresimulator.engine.{ActorType, TraceLogger}
import malwaresimulator.engine.core.Message

import scala.concurrent.duration.DurationInt

object Application {
  def apply(id: Int, name: String, node: ActorRef[Message.NodeCommand]) = {
    TraceLogger.info(ActorType.Application, name, s"started")
    new Application(id, name, node).response()
  }
}

class Application(val id: Int, val name: String, val node: ActorRef[Message.NodeCommand]) {
  var sockets: Array[String] = Array.empty

  def response(): Behavior[Message.ApplicationCommand] = {
    import Message._
    implicit val timeout: Timeout = 3.seconds
    Behaviors.receive { (context, message) =>
      message match {
        case SocketApp(replyTo, key) =>
          context.askWithStatus(node, ref => SocketSys(ref, context.self, key)){
            case Success(_) => SocketSuccess(key, replyTo)
            case Failure(ex) => SocketFailure(ex, replyTo)
          }
          Behaviors.same
        case SocketSuccess(key, replyTo) =>
          sockets = sockets :+ key
          replyTo ! StatusReply.Success()
          Behaviors.same
        case SocketFailure(ex, replyTo) =>
          replyTo ! StatusReply.error(ex)
          Behaviors.same

        case SendApp(replyTo, key, dstAddress, dstPort, data) =>
          sockets.exists(s => s == key) match {
            case true =>
              context.askWithStatus(node, ref => SendSys(ref, key, data, dstAddress, dstPort)) {
                case Success(_) => SendSuccess(replyTo)
                case Failure(ex) => SendFailure(replyTo, ex)
              }
              TraceLogger.info(ActorType.Application, this.name, s"send $data" )
            case false =>
              replyTo ! StatusReply.Error(s"Not found socket: $key")
          }
          Behaviors.same
        case SendSuccess(replyTo) =>
          replyTo ! StatusReply.success()
          Behaviors.same
        case SendFailure(replyTo, ex) =>
          replyTo ! StatusReply.error(ex)
          Behaviors.same

        case BindApp(replyTo, socket, address, port) =>
          sockets.exists(s => s == socket) match {
            case true =>
              context.askWithStatus(node, ref => BindSys(ref, socket, address, port)) {
                case Success(_) => BindSuccess(replyTo, socket)
                case Failure(ex) => BindFailure(replyTo, ex)
              }
            case false =>
              replyTo ! StatusReply.error(s"Not found socket: $socket")
          }
          Behaviors.same
        case BindSuccess(replyTo, socket) =>
          replyTo ! StatusReply.success(socket)
          Behaviors.same
        case BindFailure(replyTo, ex) =>
          replyTo ! StatusReply.error(ex)
          Behaviors.same

        case ConnectApp(replyTo, socket, dstAddress, dstPort) =>
          sockets.exists(s => s == socket) match {
            case true =>
              context.askWithStatus(node, ref => ConnectSys(ref, socket, dstAddress, dstPort)) {
                case Success(_) => ConnectSuccess(replyTo, socket)
                case Failure(ex) => ConnectFailure(replyTo, ex)
              }
            case false =>
              replyTo ! StatusReply.error(s"Not found socket: $socket")
          }
          Behaviors.same
        case ConnectSuccess(replyTo, socket) =>
          replyTo ! StatusReply.success(socket)
          Behaviors.same
        case ConnectFailure(replyTo, ex) =>
          replyTo ! StatusReply.error(ex)
          Behaviors.same

        case RecvApp(replyTo, socket) =>
          sockets.exists(s => s == socket) match {
            case true =>
              context.askWithStatus(node, ref => RecvSys(ref, socket)) {
                case Success(data) => RecvSuccess(replyTo, data)
                case Failure(ex) => RecvFailure(replyTo, ex)
              }
          }
          Behaviors.same
        case RecvSuccess(replyTo, data) =>
          replyTo ! StatusReply.success(data)
          Behaviors.same
        case RecvFailure(replyTo, ex) =>
          replyTo ! StatusReply.error(ex)
          Behaviors.same

        case ReadFileApp(replyTo, name) =>
          context.askWithStatus(node, ref => ReadFileSys(ref, name)) {
            case Success(value) => ReadFileSuccess(replyTo, value)
            case Failure(ex) => ReadFileFailure(replyTo, ex)
          }
          Behaviors.same
        case ReadFileSuccess(replyTo, file) =>
          replyTo ! StatusReply.success(file)
          Behaviors.same
        case ReadFileFailure(replyTo, ex) =>
          replyTo ! StatusReply.error(ex)
          Behaviors.same

        case StopApp() =>
          TraceLogger.info(ActorType.Application, name, "received KillApp() and then stopping...")
          Behaviors.stopped
      }
    }
  }
}
