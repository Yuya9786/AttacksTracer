package malwaresimulator.engine.applications

import scala.util.{Failure, Success}
import akka.actor.typed.{ActorRef, Behavior}
import akka.actor.typed.scaladsl.Behaviors
import akka.pattern.StatusReply
import akka.util.Timeout
import malwaresimulator.engine.TraceLogger
import malwaresimulator.engine.core.{Datagram, Http, InetAddress, Message, Protocol, Raw}
import malwaresimulator.engine.nodes.Socket

import scala.concurrent.duration.DurationInt

object Application {
  def apply(id: Int, name: String, node: ActorRef[Message.NodeCommand]) = {
    TraceLogger.info(name, s"is started.")
    new Application(id, name, node).response()
  }
}

class Application(val id: Int, val name: String, val node: ActorRef[Message.NodeCommand]) {
  var sockets: Array[Socket] = Array.empty

  def response(): Behavior[Message.ApplicationCommand] = {
    import Message._
    implicit val timeout: Timeout = 3.seconds
    Behaviors.receive { (context, message) =>
      message match {
        case SocketApp(replyTo) =>
          context.askWithStatus(node, ref => SocketSys(ref, context.self)){
            case Success(socket) => SocketSuccess(socket, replyTo)
            case Failure(ex) => SocketFailure(ex, replyTo)
          }
          Behaviors.same
        case SocketSuccess(socket, replyTo) =>
          sockets :+ socket
          replyTo ! StatusReply.Success(socket)
          Behaviors.same
        case SocketFailure(ex, replyTo) =>
          replyTo ! StatusReply.error(ex)
          Behaviors.same

        case SendApp(replyTo, socket, dstAddress, dstPort, data) =>
          sockets.exists(s => s == socket) match {
            case true =>
              context.askWithStatus(node, ref => SendSys(ref, socket, data, dstAddress, dstPort)) {
                case Success(_) => SendSuccess(replyTo)
                case Failure(ex) => SendFailure(replyTo, ex)
              }
            case false =>
              replyTo ! StatusReply.Error(s"Not found socket: $socket")
          }
          Behaviors.same
        case SendSuccess(replyTo) =>
          replyTo ! StatusReply.success()
          Behaviors.same
        case SendFailure(replyTo, ex) =>
          replyTo ! StatusReply.error(ex)
          Behaviors.same

        case BindApp(replyTo, socket, address, port) =>
          sockets.exists(s => s == socket) match {
            case true =>
              context.askWithStatus(node, ref => BindSys(ref, socket, address, port)) {
                case Success(socket) => BindSuccess(replyTo, socket)
                case Failure(ex) => BindFailure(replyTo, ex)
              }
            case false =>
              replyTo ! StatusReply.Error(s"Not found socket: $socket")
          }
          Behaviors.same
        case BindSuccess(replyTo, socket) =>
          replyTo ! StatusReply.success(socket)
          Behaviors.same
        case BindFailure(replyTo, ex) =>
          replyTo ! StatusReply.error(ex)
          Behaviors.same

        case RecvApp(replyTo: ActorRef[StatusReply[Datagram]], socket: Socket) =>
          sockets.exists(s => s == socket) match {
            case true =>
              context.askWithStatus(node, ref => RecvSys(ref, socket)) {
                case Success(data) => RecvSuccess(replyTo, data)
                case Failure(ex) => RecvFailure(replyTo, ex)
              }
          }
          Behaviors.same
        case RecvSuccess(replyTo, data) =>
          replyTo ! StatusReply.success(data)
          Behaviors.same
        case RecvFailure(replyTo, ex) =>
          replyTo ! StatusReply.error(ex)
          Behaviors.same
      }
    }
  }
}
