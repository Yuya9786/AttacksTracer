//package malwaresimulator.engine.applications
//
//import akka.actor.typed.scaladsl.{ActorContext, Behaviors, StashBuffer}
//import akka.actor.typed.{ActorRef, ActorSystem, Behavior}
//import malwaresimulator.engine.core.{Connection, Http, InetAddress, Message, NodeAddress}
//
//import scala.collection.mutable.ListBuffer
//
//class Malware(context: ActorContext[Message.ApplicationCommand],
//              buffer: StashBuffer[Message.ApplicationCommand],
//              malwareName: String, node: ActorRef[Message.NodeCommand],
//              var cc_address: InetAddress
//             ) extends ApplicationNode(node) {
//
//  override val name: String = malwareName
//  // 実行コード
//  private var code: Option[Behavior[Message.ApplicationCommand]] = Some(defaultCode)
//  // list for target nodes information
//  private var targetNodeAddresses: ListBuffer[NodeAddress] = ListBuffer.empty
//  // 攻撃に使うポート番号
//  private var ports: ListBuffer[Int] = ListBuffer.empty
//  // C&C サーバのアドレス
////  private var cc_address: InetAddress = InetAddress.Default
//  // プロキシ
//  private var proxyAddress: InetAddress = InetAddress.Default
//
//  override def toString: String = {
//    "malware(" + malwareName + ", node=" + node + ")"
//  }
//
//  /**
//   * マルウェアの初期化ルーチン
//   * @param f
//   */
//  def init(f: ()=>Unit): Unit = f()
//
//  /**
//   *  感染ノードを得る
//   *  @return 感染ノード
//   */
//  def getInfectedNode(): ActorRef[Message.NodeCommand] = node
//
//  /**
//   *  攻撃対象ノードのリストを得る
//   *  @return 攻撃対象ノードのリスト
//   */
//  def getTargetNodeAddresses(): ListBuffer[NodeAddress] = targetNodeAddresses
//
//  def appendTargetNode(n: NodeAddress): Unit = {
//    targetNodeAddresses += n
//  }
//
//  def getCCServerAddress(): InetAddress = cc_address
//
//  def setCCServerAddress(address: InetAddress): Unit = cc_address = address
//
//  def response(): Behavior[Message.ApplicationCommand] = {
//    import Message._
//    Behaviors.receive { (context, message) =>
//      message match {
//        case OpenedSocket(s) =>
//          this.socket = Some(s)
//          action()
//        case RecvFrom(s, data, option, srcAddress, srcPort) =>
//          data match {
//            case http: Http if http.headersMap.contains("action") =>
//              action()
//              Behaviors.same
//            case http: Http if http.headersMap.contains("action") => option match {
//              case x: InetAddress =>
//                this.cc_address = x
//                Behaviors.same
//              case _ =>
//                println("[ERR] Unknown additional information")
//                Behaviors.same
//            }
//            case http: Http if http.headersMap.contains("response") =>
//              println("[INFO] Success")
//              Behaviors.same
//            case http: Http if http.headersMap.contains("fetchres") =>
//              http.body match {
//                case malware: Behavior[ApplicationCommand] =>
//                  update(malware)
//                  println("[INFO] Code is fetched from C&CServer and set.")
//                  Behaviors.same
//                case _ =>
//                  println("[ERR] Unknown Code.")
//                  Behaviors.same
//              }
//            case http: Http if http.headersMap.contains("datares") =>
//              println("[INFO] Data has been sent successfully.")
//              Behaviors.same
//            case http: Http if http.headersMap.contains("getAnotherMalware") =>
//              http.body match {
//                case malware: ActorRef[ApplicationCommand] =>
//                  println("[INFO] Another malware is loaded.")
//                  println("Now, try to infect another malware with this node.")
//                  infect(this.node, malware)
//                  Behaviors.same
//                case _ =>
//                  println("[ERR] Unknown malware.")
//                  Behaviors.same
//              }
//            case _ =>
//              println(s"[ERR] Unknown data: ${data}")
//              Behaviors.same
//
//          }
//      }
//    }
//  }
//
//  /**
//   * 攻撃等を実行する
//   */
//  def action(): Behavior[Message.ApplicationCommand] = {
//    println(s"[Malware]: ${this} takes action.")
//    //println("Malware: Request to C&Cserver")
//    code match {
//      case Some(c) =>
//        c
//      case None =>
//        println("[ERR] Malware code is not found.")
//        response()
//    }
//  }
//
//  def search(): Unit = {
//    node ! Message.ShowConnections(context.self)
//  }
//
//  /**
//   * マルウェアのコードを更新するf
//   * @param code 新しいコード
//   */
//  def update(code: Behavior[Message.ApplicationCommand]): Unit = {
//    this.code = Some(code)
//  }
//
//  /**
//   * Proxy Address のゲッタ
//   * @return プロキシのアドレス
//   */
////  def getProxyAddress(): InetAddress = proxyAddress
//
//  /**
//   * プロキシを発見して設定する
//   */
////  def investigateProxyAddress(): InetAddress = {
////    this.proxyAddress =
////  }
//
//  def defaultCode: Behavior[Message.ApplicationCommand] = {
//    import Message._
//    search()
//
//    Behaviors.receiveMessage {
//      case ConnectionsList(conList) =>
//        val connections : ListBuffer[Connection] = conList
//        println(this, "connection: " + connections)
//        connections.foreach {
//          conn: Connection => {
//            conn.network ! ShowNode(context.self)
//          }
//        }
//        if (connections.nonEmpty) {
//          collectNodeAddress(connections.length)
//        } else {
//          println(this, "Malware: appended TargetNodeAddress")
//          targetNodeAddresses.foreach(node => println(this, "   " + node))
//          update("search", targetNodeAddresses.toList)
//          buffer.unstashAll(response())
//        }
//      case other =>
//        buffer.stash(other)
//        Behaviors.same
//    }
//  }
//
//  def collectNodeAddress(number: Int): Behavior[Message.ApplicationCommand] = {
//    import Message._
//    Behaviors.receiveMessage{
//      case Nodes(list) =>
//        val n = number - 1
//        println("list: " + list)
//        targetNodeAddresses = targetNodeAddresses ++ list
//        n match {
//          case i: Int if i > 0 =>
//            collectNodeAddress(n)
//          case 0 =>
//            println(this + "Malware: appended TargetNodeAddress")
//            targetNodeAddresses.foreach(node => println(this, "   " + node))
//            update("search", targetNodeAddresses.toList)
//            buffer.unstashAll(response())
//        }
//      case other =>
//        buffer.stash(other)
//        Behaviors.same
//    }
//  }
//
//  def update(payload: String, body: Any) = {
//    if (proxyAddress != InetAddress.Default) {
////      node ! PayloadFromApp(Http(Map("payload" -> payload, "request" -> "POST", "proxy" -> cc_address.toString), option), )
//    } else {
//      socket match {
//        case Some(s) =>
//          node ! Message.SendTo(s, Http(Map("request" -> "POST", "payload" -> payload), body), cc_address, 80)
//          println(s"[INFO] ${this} sent c&c server ${payload}")
//        case None =>
//          println("[ERR] Socket Not Found.")
//      }
//
//    }
//  }
//
//  def infect(node: ActorRef[Message.NodeCommand], malware: ActorRef[Message.ApplicationCommand]): Unit = {
//    node ! Message.Infect(malwareName, malware, cc_address)
//  }
//}
//
//object Malware {
//  def apply(name: String, node: ActorRef[Message.NodeCommand], cc_address: InetAddress): Behavior[Message.ApplicationCommand] = {
//    println(s"[INFO] Malware: ${name} started.")
//    Behaviors.withStash(100) { buffer =>
//      Behaviors.setup[Message.ApplicationCommand] { context =>
//        val malware = new Malware(context, buffer, name, node, cc_address)
//        malware.node ! Message.SocketOpen(context.self)
//        malware.response()
//      }
//    }
//  }
//}
