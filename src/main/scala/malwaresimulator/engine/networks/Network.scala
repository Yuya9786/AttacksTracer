package malwaresimulator.engine.networks

import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.{ActorRef, Behavior}
import akka.pattern.StatusReply
import akka.util.Timeout
import malwaresimulator.engine.{ActorType, TraceLogger}
import malwaresimulator.engine.core.{Datagram, InetAddress, Message}
import malwaresimulator.proto

import scala.collection.mutable.ListBuffer
import scala.concurrent.duration.DurationInt

case class NodeAddress(node: ActorRef[Message.NodeCommand], address: InetAddress)

object Network {

  def apply(id: Int, networkName: String, netAddress: InetAddress, subnetMask: Int): Behavior[Message.NetworkCommand] = {
    TraceLogger.info(ActorType.Network, networkName, "started")
    new Network(id, networkName, netAddress, subnetMask).receive()
  }
}

class Network(val id: Int, val networkName: String, val netAddress: InetAddress, val subnetMask: Int) {

  private var nodes: ListBuffer[NodeAddress] = ListBuffer.empty
  def receive(): Behavior[Message.NetworkCommand] = {
    import Message._
    implicit val timeout: Timeout = Timeout(3.seconds)
    Behaviors.receive { (context, message) =>
      message match {
        case AddNode(replyTo, node, address) =>
          nodes.find(n => n.address == address) match {
            case Some(n) =>
              replyTo ! StatusReply.Error(s"Node($n) has been added already.")
              Behaviors.same
            case None =>
              nodes += NodeAddress(node, address)
              replyTo ! StatusReply.Success()
              Behaviors.same
          }
        case RemoveNode(node, address) =>
          nodes -= NodeAddress(node, address)
          Behaviors.same
        case ShowNode(replyTo) =>
          replyTo ! Nodes(nodes)
          Behaviors.same
        case ShowNetwork(replyTo) =>
          val uuid = java.util.UUID.randomUUID().toString
          context.spawn(collectNodeInfo(replyTo), s"ShowNetworkActor-$uuid")
          Behaviors.same
        case d: Datagram =>
          TraceLogger.info(ActorType.Network, this.networkName,"received", d)
          var dstAddress: InetAddress = d.dstAddress
          if (d.nexthop != null) dstAddress = d.nexthop
          nodes.find(n => n.address == dstAddress) match {
            case Some(n) =>
              n.node ! d
              TraceLogger.info(ActorType.Network, this.networkName, s"switched to ${n.address.toString}", d)
              Behaviors.same
            case None =>
              TraceLogger.error(ActorType.Network, this.networkName, "destination node is not found", d)
              Behaviors.same
          }

        case StopNetwork() =>
          Behaviors.stopped
      }
    }
  }

  def collectNodeInfo(replyTo: ActorRef[StatusReply[proto.Network]]): Behavior[AnyRef] = {
    Behaviors.setup[AnyRef] { context =>
      nodes.foreach(_.node ! Message.GetApplications(context.self))
      var count = nodes.length
      var list: Seq[proto.Node] = Seq.empty
      def next(): Behavior[AnyRef] = {
        if (count > 0) {
          Behaviors.same
        } else {
          replyTo ! StatusReply.Success(proto.Network(id, networkName, netAddress.toString, subnetMask, list))
          Behaviors.stopped
        }
      }

      Behaviors.receiveMessage {
        case node: proto.Node =>
          count -= 1
          list = list :+ node
          next()
        case _ =>
          Behaviors.unhandled
      }
    }
  }
}