package malwaresimulator.interface

import akka.actor.typed.{ActorRef, ActorSystem}
import akka.actor.typed.scaladsl.AskPattern._
import akka.util.Timeout
import malwaresimulator.Initiator
import malwaresimulator.Initiator.AddNode
import malwaresimulator.MalwareSimulatorSupervisor.ShowNet
import malwaresimulator.engine.core.Message

import scala.io.{BufferedSource, Source}
import org.json4s.JsonAST.JObject
import org.json4s.jackson.JsonMethods

import scala.collection.mutable
import scala.concurrent.duration.DurationInt
import scala.util.{Failure, Success}

object Solver {
  def apply(system: ActorSystem[Initiator.Command]): Solver = {
    new Solver(system)
  }
}

class Solver(val theSystem: ActorSystem[Initiator.Command]) {
  implicit val timeout: Timeout = 3.seconds
  implicit val system: ActorSystem[Initiator.Command] = theSystem
  implicit val ec = system.executionContext

  var id = 0
  var actors: Actors = Actors(mutable.Map.empty, mutable.Map.empty, mutable.Map.empty)

  def apply(): Unit = {
    val file = system.settings.config.getString("malwaresimulator.file")
    val source = Source.fromFile(file)
    val jsonList = read(source)

    send(jsonList)
    println("done")
//    val r = system.ask(ref => ShowNet(ref))
//    println(r)
  }

  def read(source: BufferedSource): List[Map[String, Any]] = {
    val list: Array[Map[String, Any]] = Array.empty
    val lines = source.getLines()
    lines.foreach { line =>
      val value = JsonMethods.parse(line)
      val map = value.asInstanceOf[JObject].values
      list :+ map
    }

    list.toList
  }

  def send(json: List[Map[String, Any]]): Unit = {
    import Initiator._
    json.foreach { map =>

      map("type") match {
        case "Activity" =>
          val id = map("id").toString
          val annotations: Map[String, Any] =
            JsonMethods.parse(map("annotations").toString).asInstanceOf[JObject].values
          val machine_id = annotations("cf:machine_id").toString
          val nodeRef = nodeGet(machine_id)
          val result = system.askWithStatus(ref => AddApplication(ref, id, nodeRef))
          result.onComplete {
            case Success(appActorRef) =>
              actors.application += (id -> appActorRef)
          }
        case e =>
          println(e)

      }
    }
  }

  def nodeGet(machine_id: String): ActorRef[Message.NodeCommand] = {
    actors.node.contains(machine_id) match {
      case true => actors.node(machine_id)
      case false => {
        val node = system.askWithStatus(ref => AddNode(ref, machine_id))
        node.onComplete {
          case Success(nr) =>
            actors.node += (machine_id -> nr)
        }
        actors.node(machine_id)
      }
    }
  }
}
