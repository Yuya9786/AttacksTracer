package malwaresimulator.solver

import akka.actor.typed.{ActorRef, ActorSystem}
import akka.actor.typed.scaladsl.AskPattern._
import akka.util.Timeout
import malwaresimulator.engine.Initiator
import malwaresimulator.engine.Initiator.AddNode
import malwaresimulator.engine.core.Message
import malwaresimulator.proto

import scala.io.{BufferedSource, Source}
import org.json4s.JsonAST.JObject
import org.json4s.jackson.JsonMethods

import scala.collection.mutable
import scala.concurrent.{Await, ExecutionContextExecutor, Future}
import scala.concurrent.duration.DurationInt
import scala.util.{Failure, Success}

object Solver {
  def apply(system: ActorSystem[Initiator.Command]): Solver = {
    new Solver(system)
  }

  class Solver(val theSystem: ActorSystem[Initiator.Command]) {
    implicit val timeout: Timeout = 3.seconds
    implicit val system: ActorSystem[Initiator.Command] = theSystem
    implicit val ec: ExecutionContextExecutor = system.executionContext

    var id = 0
    var actors: Actors = Actors(mutable.Map.empty, mutable.Map.empty, mutable.Map.empty)

    def start(): Unit = {
      val file = system.settings.config.getString("malwaresimulator.file")
      val source = Source.fromFile(file)
      val jsonList = read(source)
      println(jsonList.size)
      send(jsonList)
      println("done")
//      val r = showNet()
      println(this.actors)
    }

    def read(source: BufferedSource): List[Map[String, Any]] = {
      var list: Array[Map[String, Any]] = Array.empty
      val lines = source.getLines()
      println("read(): ")
      lines.foreach { line =>
        val value = JsonMethods.parse(line)
        val map = value.asInstanceOf[JObject].values
        list = list :+ map
      }

      println("read() fin")
      list.toList
    }

    def send(json: List[Map[String, Any]]): Unit = {
      import Initiator._
      json.foreach { map =>
        map("type") match {
          case "Activity" =>
            val annotations: Map[String, Any] = map("annotations").asInstanceOf[Map[String, Any]]
            val id = annotations("object_id").toString
            val machine_id = annotations("cf:machine_id").toString
            val version = annotations("version").toString.toInt
            if (version == 0) { // version 0以外はとりあえず除外
              val nodeRef = nodeGet(machine_id)
              val result = system.askWithStatus(ref => AddApplication(ref, id, nodeRef))
              result.onComplete {
                case Success(appActorRef) =>
                  println(s"$id -> $appActorRef")
                  actors.application += (id -> appActorRef)
                case Failure(exception) =>
                  throw exception
              }
              Await.ready(result, 3.seconds)
            }
          case e =>
            println(e)

        }
      }
    }

    def nodeGet(machine_id: String): ActorRef[Message.NodeCommand] = {
      if (this.actors.node.contains(machine_id)) {
        println(machine_id + " is contained")
        this.actors.node(machine_id)
      } else {
        println(machine_id + " isn't contained")
        val node = system.askWithStatus(ref => AddNode(ref, machine_id))
        node.onComplete {
          case Success(nr) =>
            println("add " + machine_id)
            this.actors.node += (machine_id -> nr)
            this.actors.node(machine_id)
          case Failure(exception) =>
            throw exception
        }
        Await.result(node, 3.seconds)
      }
    }

    def showNet(): proto.WholeNetwork = {
      var networkList: Seq[proto.Network] = Seq.empty
      this.actors.network.foreach{ net =>
        val result = net._2.askWithStatus(Message.ShowNetwork)
        result.onComplete {
          case Success(value) => networkList = networkList :+ value
          case Failure(ex) => throw ex
        }
      }
      proto.WholeNetwork(networkList)
    }
  }
}

