package malwaresimulator.solver

import akka.actor.typed.{ActorRef, ActorSystem}
import akka.actor.typed.scaladsl.AskPattern._
import akka.util.Timeout
import malwaresimulator.engine.Initiator
import malwaresimulator.engine.Initiator.{AddApplication, AddNode}
import malwaresimulator.engine.core.Message
import malwaresimulator.engine.core.Message.{KillApp, SocketApp}
import malwaresimulator.proto

import scala.io.{BufferedSource, Source}
import org.json4s.JsonAST.JObject
import org.json4s.jackson.JsonMethods

import scala.collection.mutable
import scala.concurrent.{Await, ExecutionContextExecutor, Future}
import scala.concurrent.duration.DurationInt
import scala.util.{Failure, Success}

object Solver {
  def apply(system: ActorSystem[Initiator.Command]): Solver = {
    new Solver(system)
  }

  class Solver(val theSystem: ActorSystem[Initiator.Command]) {
    implicit val timeout: Timeout = 3.seconds
    implicit val system: ActorSystem[Initiator.Command] = theSystem
    implicit val ec: ExecutionContextExecutor = system.executionContext

    var id = 0
    var actors: Actors = Actors(mutable.Map.empty, mutable.Map.empty, mutable.Map.empty)

    def start(): Unit = {
      val file = system.settings.config.getString("malwaresimulator.file")
      val source = Source.fromFile(file)
      val jsonList = read(source)
      println(jsonList.size)
      send(jsonList)
      println("done")
//      val r = showNet()
      println(this.actors)
    }

    def read(source: BufferedSource): List[Map[String, Any]] = {
      var list: Array[Map[String, Any]] = Array.empty
      val lines = source.getLines()
      println("read(): ")
      lines.foreach { line =>
        val value = JsonMethods.parse(line)
        val map = value.asInstanceOf[JObject].values
        list = list :+ map
      }

      println("read() fin")
      list.toList
    }

    def send(json: List[Map[String, Any]]): Unit = {
      json.foreach { map =>
        map("type") match {
          case "Activity" =>
            val uid = map("id").toString
            val annotations: Map[String, Any] = map("annotations").asInstanceOf[Map[String, Any]]
            annotations("object_type") match {
              case "task" =>
                val pid = annotations("pid").toString
                val machine_id = annotations("cf:machine_id").toString
                val version = annotations("version").toString.toInt
                if (version == 0) { // version 0以外はとりあえず除外
                  val result = createApp(uid, machine_id, pid)
                  Await.ready(result, 3.seconds)
                }
            }
          case "WasGeneratedBy" =>
            val from = map("from").toString
            val to = map("to").toString
            val annotations = map("annotations").asInstanceOf[Map[String, Any]]
            annotations("relation_type") match {
              case "socket_create" =>
                val socket = from
                val task = to
                val app = actors.application(task)
                val result = app.askWithStatus(ref => SocketApp(ref, socket))
                Await.ready(result, 3.seconds)
            }

          case "WasInformedBy" =>
            val from = map("from").toString
            val to = map("to").toString
            val annotations: Map[String, Any] = map("annotations").asInstanceOf[Map[String, Any]]
            annotations("relation_type") match {
              case "terminate_task" =>
                val app = actors.application(from)
                app ! KillApp()
            }
          case e =>
            println(e)

        }
      }
    }

    def createApp(uid: String, machine_id: String, pid: String): Future[ActorRef[Message.ApplicationCommand]] = {
      val nodeRef = nodeGet(machine_id)
      val result = system.askWithStatus(ref => AddApplication(ref, pid, nodeRef))
      result.onComplete {
        case Success(appActorRef) =>
          println(s"$uid -> $appActorRef")
          actors.application += (uid -> appActorRef)
        case Failure(exception) =>
          throw exception
      }
      result
    }

    def nodeGet(machine_id: String): ActorRef[Message.NodeCommand] = {
      if (this.actors.node.contains(machine_id)) {
        println(machine_id + " is contained")
        this.actors.node(machine_id)
      } else {
        println(machine_id + " isn't contained")
        val node = system.askWithStatus(ref => AddNode(ref, machine_id))
        node.onComplete {
          case Success(nr) =>
            println("add " + machine_id)
            this.actors.node += (machine_id -> nr)
            this.actors.node(machine_id)
          case Failure(exception) =>
            throw exception
        }
        Await.result(node, 3.seconds)
      }
    }

    def showNet(): proto.WholeNetwork = {
      var networkList: Seq[proto.Network] = Seq.empty
      this.actors.network.foreach{ net =>
        val result = net._2.askWithStatus(Message.ShowNetwork)
        result.onComplete {
          case Success(value) => networkList = networkList :+ value
          case Failure(ex) => throw ex
        }
      }
      proto.WholeNetwork(networkList)
    }
  }
}

