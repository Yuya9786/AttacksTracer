package malwaresimulator.solvers

import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.AskPattern._
import akka.util.Timeout
import malwaresimulator.engine.Initiator
import malwaresimulator.engine.core.{InetAddress, Message, Raw}
import malwaresimulator.proto

import java.util.concurrent.locks.ReentrantReadWriteLock
import scala.collection.mutable
import scala.concurrent.{ExecutionContextExecutor, Future}
import scala.concurrent.duration.DurationInt
import com.google.protobuf.ByteString
import malwaresimulator.engine.core.Message.AddRoute

import scala.util.{Failure, Success}

object Solver {
  def apply(system: ActorSystem[Initiator.Command]) = {
    new Solver(system)
  }
}

class Solver(val theSystem: ActorSystem[Initiator.Command]) {
  implicit val timeout: Timeout = 3.seconds
  implicit val system: ActorSystem[Initiator.Command] = theSystem
  implicit val ec: ExecutionContextExecutor = system.executionContext

  val lock = new ReentrantReadWriteLock(true)
  var id = 0
  var actors: Actors = Actors(mutable.Map.empty, mutable.Map.empty, mutable.Map.empty)

  def addNode(name: String): Future[proto.Node] = {
    val result = system.askWithStatus(ref => Initiator.AddNode(ref, name))
    result map { ref =>
      lock.writeLock().lock()
      actors.node += (id -> ref)
      val r = id
      id += 1
      lock.writeLock().unlock()
      r
    } recover {
      case ex => throw ex
    } map { r =>
      proto.Node(r, name)
    }
  }

  def updateNodeInfo(id: Int): Future[proto.Node] = {
    val node = actors.node(id)
    val result = node.askWithStatus(ref => Message.UpdateNodeInfo(ref, id))
    result.onComplete {
      case Success(_) => ()
      case Failure(exception) => throw exception
    }
    result
  }

  def addNetwork(name: String, address: String, subnetMask: Int): Future[proto.Network] = {
    val result = system.askWithStatus(ref => Initiator.AddNetwork(ref, name, InetAddress(address), subnetMask))
    result map { ref =>
      lock.writeLock().lock()
      actors.network += (id -> ref)
      val r = id
      id += 1
      lock.writeLock().unlock()
      r
    } recover {
      case ex => throw ex
    } map { r =>
      proto.Network(r, name, address, subnetMask)
    }
  }

  def addApplication(name: String, nodeId: Int): Future[proto.Application] = {
    lock.readLock().lock()
    val node = actors.node(nodeId)
    lock.readLock().unlock()

    val result = system.askWithStatus(ref => Initiator.AddApplication(ref, name, node))
    result map { ref =>
      lock.writeLock().lock()
      actors.application += (id -> ref)
      val r = id
      id += 1
      lock.writeLock().unlock()
      r
    } recover {
      case ex => throw ex
    } map { r =>
      proto.Application(r, name)
    }
  }

  def remove(id: Int): Future[proto.RemoveReply] = {
    lock.readLock().lock()
    val node = actors.node.get(id)
    val net = actors.network.get(id)
    val app = actors.application.get(id)
    lock.readLock().unlock()

    if (node.isDefined) {
      node.map(ref => ref ! Message.StopNode())
    } else if (net.isDefined) {
      net.map(ref => ref ! Message.StopNetwork())
    } else if (app.isDefined) {
      app.map(ref => ref ! Message.StopApp())
    }

    Future {
      proto.RemoveReply()
    }
  }

  def makeConnection(nodeId: Int, netId: Int, address: String, subnetMask: Int): Future[proto.Network] = {
    lock.writeLock().lock()
    val node = actors.node(nodeId)
    val network = actors.network(netId)
    lock.writeLock().unlock()

    val result1 =
      system.askWithStatus(ref => Initiator.MakeConnection(ref, node, network, InetAddress(address), subnetMask))

    result1 flatMap { _ =>
      network.askWithStatus(Message.ShowNetwork)
    } recover {
      case ex => throw ex
    }
  }

  def addRoute(nodeID: Int, dstAddress: String, mask: Int, nexthop: String, netID: Int): Future[proto.AddRouteReply] = {
    lock.writeLock().lock()
    val node = actors.node(nodeID)
    val network = actors.network(netID)
    lock.writeLock().unlock()

    node.askWithStatus(ref => AddRoute(ref, InetAddress(dstAddress), mask, InetAddress(nexthop), network)) map { _ =>
      proto.AddRouteReply()
    } recover {
      case ex => throw ex
    }
  }

  def sendPacket(appID: Int, _srcAddress: String, _srcPort: Int,
                 dstAddress: String, dstPort: Int, data: ByteString): Future[proto.SendPacketReply] = {
    lock.readLock().lock()
    val app = actors.application(appID)
    lock.readLock().unlock()

    val d = Raw(data.toByteArray)

    val key = scala.util.Random.alphanumeric.take(10).mkString
    system.askWithStatus(ref => Initiator.CreateSocket(ref, app, key)) flatMap { _ =>
      system.askWithStatus(ref => Initiator.SendPacket(ref, app, key, InetAddress(dstAddress), dstPort, d)) map { _ =>
        proto.SendPacketReply()
      } recover {
        case ex => throw ex
      }
    } recover {
      case ex => throw ex
    }
  }

  def addFile(nodeID: Int, name: String, data: String): Future[proto.File] = {
    lock.readLock().lock()
    val node = actors.node(nodeID)
    lock.readLock().unlock()

    node.askWithStatus(ref => Message.AddFileSys(ref, name, data)) map { file =>
      proto.File(file.name, file.data)
    } recover {
      case ex => throw ex
    }
  }

  def readFile(appID: Int, name: String): Future[proto.File] = {
    lock.readLock().lock()
    val app = actors.application(appID)
    lock.readLock().unlock()

    app.askWithStatus(ref => Message.ReadFileApp(ref, name)) map { file =>
      proto.File(file.name, file.data)
    } recover {
      case ex => throw ex
    }
  }
}

