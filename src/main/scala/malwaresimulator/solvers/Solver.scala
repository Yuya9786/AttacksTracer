package malwaresimulator.solvers

import akka.actor.typed.{ActorRef, ActorSystem}
import akka.actor.typed.scaladsl.AskPattern._
import akka.util.Timeout
import malwaresimulator.engine.Initiator
import malwaresimulator.engine.core.InetAddress
import malwaresimulator.engine.core.Message
import malwaresimulator.proto

import scala.collection.mutable
import scala.concurrent.{Await, ExecutionContextExecutor, Future}
import scala.concurrent.duration.DurationInt
import scala.util.{Failure, Success}

object Solver {
  def apply(system: ActorSystem[Initiator.Command]) = {
    new Solver(system)
  }
}

class Solver(val theSystem: ActorSystem[Initiator.Command]) {
  implicit val timeout: Timeout = 3.seconds
  implicit val system: ActorSystem[Initiator.Command] = theSystem
  implicit val ec: ExecutionContextExecutor = system.executionContext

  var id = 0
  var actors: Actors = Actors(mutable.Map.empty, mutable.Map.empty, mutable.Map.empty)

  def addNode(name: String): Future[proto.Node] = {
    Future {
      val result = system.askWithStatus(ref => Initiator.AddNode(ref, name))
      result.onComplete {
        case Success(value) =>
          actors.node += (id -> value)
          id += 1
        case Failure(ex) => throw ex
      }

      Await.ready(result, 3.seconds)
      proto.Node(id, name)
    }
  }

  def addNetwork(name: String, address: String, subnetMask: Int): Future[proto.Network] = {
    Future {
      val result = system.askWithStatus(ref => Initiator.AddNetwork(ref, name, InetAddress(address), subnetMask))
      result.onComplete {
        case Success(value) =>
          actors.network += (id -> value)
          id += 1
        case Failure(ex) => throw ex
      }

      Await.ready(result, 3.seconds)
      proto.Network(id, name, address, subnetMask)
    }
  }

  def addApplication(name: String, nodeId: Int): Future[proto.Application] = {
    Future {
      val node = actors.node(nodeId)
      val result = system.askWithStatus(ref => Initiator.AddApplication(ref, name, node))
      result.onComplete {
        case Success(value) =>
          actors.application += (id -> value)
          id += 1
        case Failure(ex) => throw ex
      }

      Await.ready(result, 3.seconds)
      proto.Application(id, name)
    }
  }

  def makeConnection(nodeId: Int, netId: Int, address: String, subnetMask: Int): Future[proto.Network] = {
    Future {
      val node = actors.node(nodeId)
      val network = actors.network(netId)
      val result1 =
        system.askWithStatus(ref => Initiator.MakeConnection(ref, node, network, InetAddress(address), subnetMask))
      result1.onComplete {
        case Success(_) => ()
        case Failure(ex) => throw ex
      }

      Await.ready(result1, 3.seconds)

      val result2 = network.askWithStatus(Message.ShowNetwork)
      result2.onComplete {
        case Success(_) => ()
        case Failure(ex) => throw ex
      }

      Await.result(result2, 3.seconds)
    }
  }


}

