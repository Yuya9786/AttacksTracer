package malwaresimulator

import akka.actor.typed.{ActorRef, Behavior}
import akka.actor.typed.scaladsl.Behaviors
import malwaresimulator.engine.core.{Message, InetAddress}
import malwaresimulator.engine.nodes

object MalwareSimulatorSupervisor {

  trait Operation
  final case class ShowNet(replyTo: ActorRef[proto.WholeNetwork]) extends Operation
  final case class AddNode(replyTo: ActorRef[proto.Node], name: String, address: String) extends Operation
  final case class AddNetwork(replyTo: ActorRef[proto.Network], name: String, address: String, subnetMask: Int) extends Operation
  final case class MakeConnection(replyTo: ActorRef[proto.WholeNetwork], nodeId: Int, networkId: Int, address: String, subnetMask: Int) extends Operation
  final case class Infect(replyTo: ActorRef[proto.Node], nodeId: Int, malwareName: String, ccsAddress: String) extends Operation

  final case class Network(id: Int, name: String, address: InetAddress, subnetMask: Int, nodes: List[Node]) extends Operation
  final case class Node(id: Int, name: String, address: InetAddress, applications: List[Application]) extends Message.NetworkCommand
  final case class Application(id: Int, name: String)

  sealed trait Reply
  final case class WholeNetwork(networks: List[Network] /*, isolatedNodes: List[Node]*/) extends Reply

  final case class ActorType(actorRef: ActorRef[Any], t: String)

  final case class Actors(network: Map[Int, ActorRef[Message.NetworkCommand]],
                          node: Map[Int, ActorRef[Message.NodeCommand]],
                          application: Map[Int, ActorRef[Message.ApplicationCommand]])

  def apply: Behaviors.Receive[Operation] = apply(Actors(Map.empty, Map.empty, Map.empty), 1)

  def apply(actors: Actors, id: Int): Behaviors.Receive[Operation] = Behaviors.receive {
    case (context, ShowNet(replyTo)) =>
      println("Supervisor received ShowNet")
      val uuid = java.util.UUID.randomUUID().toString
      context.spawn(collectNetworkInfo(actors, replyTo), s"collectNetworkInfo-$uuid")
      Behaviors.same
    case (ctx, AddNode(replyTo, name, address)) =>
      val nodeRef = ctx.spawn(nodes.Node(id, name, InetAddress(address)), name)
      replyTo ! proto.Node(id, name, address, List.empty)
      apply(Actors(actors.network, actors.node + (id -> nodeRef), actors.application), id + 1)
    case (ctx, AddNetwork(replyTo, name, address, subnetMask)) =>
      val networkRef = ctx.spawn(malwaresimulator.Network(id, name, InetAddress(address), subnetMask), name)
      replyTo ! proto.Network(id, name, address, subnetMask)
      apply(Actors(actors.network + (id -> networkRef), actors.node, actors.application), id + 1)
    case (ctx, MakeConnection(replyTo, nodeId, networkId, address, subnetMask)) =>
      val nodeRef = actors.node(nodeId)
      val networkRef = actors.network(networkId)
      (nodeRef, networkRef) match {
        case (nodeRef: ActorRef[Message.NodeCommand], networkRef: ActorRef[Message.NetworkCommand]) =>
          networkRef ! Message.AddNode(nodeRef, InetAddress(address))
          nodeRef ! Message.MakeConnection(InetAddress(address), subnetMask, networkRef)
          val uuid = java.util.UUID.randomUUID().toString
          ctx.spawn(collectNetworkInfo(actors, replyTo), s"collectNetworkInfo-$uuid")
        case _ =>
          ()
      }
      Behaviors.same
    case (ctx, Infect(replyTo, nodeId, malwareName, ccsAddress)) =>
      val nodeRef = actors.node(nodeId)
      val malwareRef = ctx.spawn(malwaresimulator.engine.applications.Malware(malwareName, nodeRef, InetAddress(ccsAddress)), malwareName)
      Behaviors.same
  }

  def collectNetworkInfo(actors: Actors, replyTo: ActorRef[proto.WholeNetwork]): Behavior[AnyRef] = {
    Behaviors.setup[AnyRef] { context =>
      var count = 0
      var list: Seq[proto.Network] = Seq.empty
      actors.network.foreach{ case (id, net) =>
        net ! Message.ShowNetwork(context.self)
        count += 1
      }

      def next(): Behavior[AnyRef] = {
        if (count > 0) {
          Behaviors.same
        } else {
          replyTo ! proto.WholeNetwork(list)
          Behaviors.stopped
        }
      }

      next()
      Behaviors.receiveMessage {
        case n: proto.Network =>
          list = list :+ n
          count -= 1
          next()
        case _ =>
          Behaviors.unhandled
      }
    }
  }
}
