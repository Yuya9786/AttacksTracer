package malwaresimulator

import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.{ActorRef, Behavior}
import akka.pattern.StatusReply
import akka.util.Timeout
import malwaresimulator.MalwareSimulatorSupervisor.Operation
import malwaresimulator.engine.core.Message.{ApplicationCommand, NetworkCommand, NodeCommand}
import malwaresimulator.engine.core.{InetAddress, Message}
import malwaresimulator.engine.{TraceLogger, applications, core, nodes}

import scala.concurrent.duration.DurationInt
import scala.util.{Failure, Success}

object Initiator {
  trait Command
  case class AddNode(replyTo: ActorRef[StatusReply[ActorRef[NodeCommand]]], name: String) extends Command
  case class AddNetwork(replyTo: ActorRef[StatusReply[ActorRef[NetworkCommand]]], name: String, address: InetAddress, netmask: Int) extends Command
  case class AddApplication(replyTo: ActorRef[StatusReply[ActorRef[ApplicationCommand]]], name: String, node: ActorRef[NodeCommand]) extends Command
  case class AddApplicationSuccess(replyTo: ActorRef[StatusReply[ActorRef[ApplicationCommand]]], app: ActorRef[ApplicationCommand]) extends Command
  case class AddApplicationFailure(replyTo: ActorRef[StatusReply[ActorRef[ApplicationCommand]]], ex: Throwable) extends Command
  case class MakeConnection(replyTo: ActorRef[StatusReply[_]], node: ActorRef[NodeCommand], network: ActorRef[NetworkCommand], address: InetAddress, mask: Int) extends Command
  case class MakeConnectionSuccess(replyTo: ActorRef[StatusReply[_]]) extends Command
  case class MakeConnectionFailure(replyTo: ActorRef[StatusReply[_]], throwable: Throwable) extends Command
  case class Infect(replyTo: ActorRef[StatusReply[ActorRef[ApplicationCommand]]], name: String, nodeRef: ActorRef[NodeCommand], ccAddress: InetAddress) extends Command
  case class InfectSuccess(replyTo: ActorRef[StatusReply[ActorRef[ApplicationCommand]]], malware: ActorRef[ApplicationCommand]) extends Command
  case class InfectFailure(replyTo: ActorRef[StatusReply[ActorRef[ApplicationCommand]]], throwable: Throwable) extends Command

  trait Reply
  final case class Network(id: Int, name: String, address: InetAddress, subnetMask: Int, nodes: List[Node]) extends Reply
  final case class Node(id: Int, name: String, address: InetAddress, applications: List[Application]) extends Reply
  final case class Application(id: Int, name: String) extends Reply

  val start: Behavior[Command] = Behaviors.setup { context =>
    implicit val timeout: Timeout = 3.seconds
    var id = 0

    Behaviors.receiveMessage {
      case AddNode(replyTo, name) =>
        val nodeRef = context.spawn(nodes.Node(id, name), name)
        id += 1
        replyTo ! StatusReply.success(nodeRef)
        Behaviors.same

      case AddNetwork(replyTo, name, address, mask) =>
        val networkRef = context.spawn(core.Network(id, name, address, mask), name)
        id += 1
        replyTo ! StatusReply.success(networkRef)
        Behaviors.same

      case AddApplication(replyTo, name, node) =>
        val app = context.spawn(applications.Application(id, name, node), name)
        id += 1
        context.askWithStatus(node, ref => Message.SetApplication(ref, id, name)) {
          case Success(_) => AddApplicationSuccess(replyTo, app)
          case Failure(ex) => AddApplicationFailure(replyTo, ex)
        }
        Behaviors.same
      case AddApplicationSuccess(replyTo, app) =>
        replyTo ! StatusReply.success(app)
        Behaviors.same
      case AddApplicationFailure(replyTo, ex) =>
        replyTo ! StatusReply.error(ex)
        Behaviors.same

      case MakeConnection(replyTo, node, network, address, mask) =>
        context.askWithStatus(node, ref => Message.MakeConnection(ref, address, mask, network)) {
          case Success(_) => MakeConnectionSuccess(replyTo)
          case Failure(exception) => MakeConnectionFailure(replyTo, exception)
        }
        Behaviors.same
      case MakeConnectionSuccess(replyTo) =>
        replyTo ! StatusReply.Success()
        Behaviors.same
      case MakeConnectionFailure(replyTo, exception) =>
        replyTo ! StatusReply.error(exception)
        Behaviors.same

      case Infect(replyTo, name, node, ccAddress) =>
        val malware = context.spawn(malwaresimulator.engine.applications.Malware(name, node, ccAddress), name)
        context.askWithStatus(node, ref => Message.Infect(ref, name, node, ccAddress)) {
          case Success(_) => InfectSuccess(replyTo, malware)
          case Failure(exception) => InfectFailure(replyTo, exception)
        }
        Behaviors.same
      case InfectSuccess(replyTo, malware) =>
        replyTo ! StatusReply.success(malware)
        Behaviors.same
      case InfectFailure(replyTo, ex) =>
        replyTo ! StatusReply.error(ex)
        Behaviors.same
    }
  }
}
